import pygame as pyg
from collections import defaultdict

STEP = 5

DIMENSION = 95

BOARD_SIZE = 4

WINDOW_LENGTH = BOARD_SIZE*(DIMENSION + STEP) + STEP

WINDOW_SIZE = (WINDOW_LENGTH, WINDOW_LENGTH)

POS_VALUES = [STEP + j*(DIMENSION + STEP) for j in range(0, BOARD_SIZE)]

PLACEHOLDER_ARRAY = [[pyg.Rect(x, y, DIMENSION, DIMENSION) for y in POS_VALUES] for x in POS_VALUES]

NUMBER_LIST = [2**x for x in range(1, 20)]

NUMBER_COLOR_DICT = defaultdict(lambda: (0, 0, 0))

NUMBER_COLOR_DICT[NUMBER_LIST[ 0]] = (238, 228, 218)
NUMBER_COLOR_DICT[NUMBER_LIST[ 1]] = (237, 224, 200)
NUMBER_COLOR_DICT[NUMBER_LIST[ 2]] = (242, 177, 121)
NUMBER_COLOR_DICT[NUMBER_LIST[ 3]] = (245, 149,  99)
NUMBER_COLOR_DICT[NUMBER_LIST[ 4]] = (246, 124,  95)
NUMBER_COLOR_DICT[NUMBER_LIST[ 5]] = (246,  94,  59)
NUMBER_COLOR_DICT[NUMBER_LIST[ 6]] = (237, 207, 114)
NUMBER_COLOR_DICT[NUMBER_LIST[ 7]] = (237, 204,  97)
NUMBER_COLOR_DICT[NUMBER_LIST[ 8]] = (237, 200,  80)
NUMBER_COLOR_DICT[NUMBER_LIST[ 9]] = (237, 198,  65)
NUMBER_COLOR_DICT[NUMBER_LIST[10]] = (237, 194,  46)

from random import *
from copy import deepcopy
import jsonpickle
import os
import threading
from math import log10
import itertools as it

pyg.font.init()

def do_twice(func):
    def wrapper(*args, **kwargs):
        func(*args, **kwargs)
        func(*args, **kwargs)
    return wrapper

class Direction():
    UP    = pyg.Vector2( 0, -1) 
    DOWN  = pyg.Vector2( 0,  1) 
    LEFT  = pyg.Vector2(-1,  0) 
    RIGHT = pyg.Vector2( 1,  0) 
    NONE  = pyg.Vector2( 0,  0)
    LIST  = [] #Order : Up, down, left, right
    
    @classmethod
    def init(cls):
        cls.LIST = [cls.UP, cls.DOWN, cls.LEFT, cls.RIGHT]
    

class Board():
    HIGHER_NUMBER_CHANCE = 0.10

    class Tile(pyg.sprite.Sprite):
        font_dict = {digit : pyg.font.Font("ClearSans-Bold.ttf", int(2 * DIMENSION / (digit + 1))) for digit in range(3, 7 + 1)}
        SPEED = 10

        def __init__(self, location, number):
            pyg.sprite.Sprite.__init__(self)
            self.number = number
            self.grid_coords = location
            self.dir = Direction.NONE
            self.update_rectangle()
            self.update_text()
            self.set_color()
            self.merged = False #Flag to ensure that a tile does not merge twice during a single loop (unintended behavior)

        def update_rectangle(self):
            self.rect = PLACEHOLDER_ARRAY[int(self.grid_coords.x)][int(self.grid_coords.y)].copy()

        def update_text(self):
            self.text = Board.Tile.font_dict[max(int(log10(self.number)) + 1, 3)].render(str(self.number), True, (249, 246, 242) if self.number > NUMBER_LIST[1] else (119, 110, 101))

        def initiate_move(self, dir):
            self.dir = dir

        def update(self, tile_list):
            if self.rect.left not in POS_VALUES or self.rect.top not in POS_VALUES or self._can_move(tile_list):
                self.rect.move_ip(Board.Tile.SPEED*self.dir)
            else:
                self.dir = Direction.NONE

            self._update_grid_coords()

        def _update_grid_coords(self):
            if self.rect.left in POS_VALUES and self.rect.top in POS_VALUES:
                self.grid_coords = pyg.Vector2(POS_VALUES.index(self.rect.left), POS_VALUES.index(self.rect.top))

        def _can_move(self, tile_list):
            return self.can_move(self.dir, tile_list)

        def can_move(self, dir, tile_list):
            if dir != Direction.NONE and \
               0 <= self.grid_coords.x + dir.x <= BOARD_SIZE - 1 and 0 <= self.grid_coords.y + dir.y <= BOARD_SIZE - 1:
                next_coords = self.grid_coords + dir
                next = tile_list[int(next_coords.x)][int(next_coords.y)]
                if next == 0 or (next.number == self.number and not (self.merged or next.merged)) or next.can_move(dir, tile_list):
                    return True 
            return False

        def set_color(self):
            self.color = NUMBER_COLOR_DICT[self.number]

        def double(self):
            self.number = NUMBER_LIST[NUMBER_LIST.index(self.number) + 1]
            self.merge()
            self.set_color()
            self.update_text()

        def merge(self):
            self.merged = True
        
        def draw(self):
            screen = pyg.display.get_surface()
            text_rect = self.text.get_rect()
            text_rect.center = self.rect.center

            rect = pyg.draw.rect(screen, self.color, self.rect, border_radius = 1)
            screen.blit(self.text, text_rect)
            return rect

    def __init__(self):
        self.group = pyg.sprite.Group()
        self.array_moving = False
        self.try_read_file()

    @do_twice
    def start(self):
        board_list = self.generate_list()
        self.add_tile(board_list)

    def reset(self, wait = True):
        if wait:
            event = threading.Event()
            event.wait(timeout=2)
        self.group.empty()
        self.start()
    
    def add_tile(self, board_list):
        zeros = []
        for x, row in enumerate(board_list):
            for y, tile_space in enumerate(row):
                if tile_space == 0:
                    zeros.append(pyg.Vector2(x, y))
        if zeros:
            self.group.add(Board.Tile(choice(zeros), NUMBER_LIST[1] if random() <= Board.HIGHER_NUMBER_CHANCE else NUMBER_LIST[0]))

    def move_board(self, dir):
        for tile in self.group:
            tile.initiate_move(dir)

    def generate_list(self):
        a = [[0 for y in range(0, BOARD_SIZE)] for x in range(0, BOARD_SIZE)]
        for tile in self.group:
            a[int(tile.grid_coords.x)][int(tile.grid_coords.y)] = tile
        return a
        
    def draw(self):
        rect_list = []
        for tile in self.group:
            rect_list.append(tile.draw())
        pyg.display.update(rect_list)

    def update(self):
        board_list = self.generate_list()

        last_array_moving = deepcopy(self.array_moving)
        self.array_moving = False

        for tile in self.group:
            tile.update(board_list)
            if tile.dir != Direction.NONE:
                self.array_moving = True
        if last_array_moving:
            self.merge()
            if not self.array_moving:
                for tile in self.group:
                    tile.merged = False
                self.add_tile(board_list)
        if self.check_loss(board_list):
            self.reset()

    def on_keydown(self):
        if not self.array_moving:
            dir = Direction.NONE
            if pyg.key.get_pressed()[pyg.K_UP]:
                dir = Direction.UP
            elif pyg.key.get_pressed()[pyg.K_DOWN]:
                dir = Direction.DOWN
            elif pyg.key.get_pressed()[pyg.K_LEFT]:
                dir = Direction.LEFT
            elif pyg.key.get_pressed()[pyg.K_RIGHT]:
                dir = Direction.RIGHT
            if dir != Direction.NONE:
                self.move_board(dir)
    def merge(self):
        for a, b in it.combinations(self.group, 2):
            if a.rect.center == b.rect.center:
                    a.double()
                    b.kill()

    def check_loss(self, tile_list):
        if len(self.group) == BOARD_SIZE**2:
            for tile in self.group:
                if tile.can_move(Direction.UP, tile_list)   or tile.can_move(Direction.DOWN, tile_list) or \
                   tile.can_move(Direction.LEFT, tile_list) or tile.can_move(Direction.RIGHT, tile_list): 
                    #Determines if any box can move in any direction
                    return False
            return True

    def try_read_file(self):
        if os.path.isfile("Saves/board.json") and os.path.getsize("Saves/board.json") != 0: 
            with open("Saves/board.json", 'r') as f:
                tile_list = jsonpickle.decode(f.read())
                for tile in tile_list:
                    tile.add(self.group)
                    tile.update_text()
                    tile.update_rectangle()
                    tile.set_color()
                f.close()
        else:
            self.start()

    def write_file(self):
        with open("Saves/board.json", 'w') as f:
            tile_list = []
            for tile in self.group:
                tile.kill() #Makes sure that the group itself is not saved
                tile_list.append(tile)
            f.write(jsonpickle.encode(tile_list, indent=4))
            f.close()

from pygame._sdl2.video import Window
import move_window as mw

def main():
    pyg.init()
    Direction.init()

    monitor = pyg.Vector2(pyg.display.Info().current_w, pyg.display.Info().current_h)
    
    screen = pyg.display.set_mode(WINDOW_SIZE, pyg.NOFRAME)
    
    window = Window.from_display_module()
    window.position = ((monitor.x - WINDOW_SIZE[0]) / 2, (monitor.y - WINDOW_SIZE[1]) / 2)

    pyg.display.set_caption("2048")

    board_instance = Board()

    game_clock = pyg.time.Clock()

    pressed = False
    start_pos = (0, 0)
    while True:
        game_clock.tick(200)

        for event in pyg.event.get():
            mouse_pos = pyg.mouse.get_pos()
            if event.type == pyg.QUIT or (event.type == pyg.KEYDOWN and pyg.key.get_pressed()[pyg.K_ESCAPE]):
                running = False
                break
            elif event.type == pyg.KEYDOWN:
                if pyg.key.get_pressed()[pyg.K_r]:
                    board_instance.reset(wait = False)
                board_instance.on_keydown()
            mw.check_event(window, event)
            
        if pyg.key.get_pressed()[pyg.K_ESCAPE]:
            break
        
        screen.fill((187, 173, 160))
        
        for placeholder in it.chain.from_iterable(PLACEHOLDER_ARRAY):
            pyg.draw.rect(screen, (205, 193, 180), placeholder, border_radius = 1)
        board_instance.draw()
        
        board_instance.update()
    
    board_instance.write_file()
    pyg.quit()

if __name__ == "__main__":
    main()